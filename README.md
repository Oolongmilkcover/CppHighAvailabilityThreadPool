# CppHighAvailabilityThreadPool

## 目录
- [CppHighAvailabilityThreadPool](#cpphighavailabilitythreadpool)
  - [目录](#目录)
  - [1. 项目名称](#1-项目名称)
  - [2. 项目介绍](#2-项目介绍)
  - [3. 核心特性](#3-核心特性)
    - [双模式工作支持](#双模式工作支持)
    - [多池共享任务队列](#多池共享任务队列)
    - [完善的任务管理](#完善的任务管理)
    - [高可靠性保障](#高可靠性保障)
    - [优雅关机机制](#优雅关机机制)
    - [高可配置性](#高可配置性)
    - [线程安全设计](#线程安全设计)
  - [4. 快速开始](#4-快速开始)
    - [环境要求](#环境要求)
    - [编译运行](#编译运行)
    - [使用示例](#使用示例)
  - [5. 详细说明](#5-详细说明)
    - [核心模块](#核心模块)
      - [任务(Task)](#任务task)
      - [任务队列(TaskQueue)](#任务队列taskqueue)
      - [线程池（ThreadPool）](#线程池threadpool)
    - [工作模式详解](#工作模式详解)
      - [FIXED 模式](#fixed-模式)
      - [CACHED 模式](#cached-模式)
  - [6. 测试](#6-测试)
  - [7. 注意事项](#7-注意事项)
  - [8. 扩展方向](#8-扩展方向)
  - [9. 开发过程中出现的问题](#9-开发过程中出现的问题)

## 1. 项目名称
**C++高可用线程池**

## 2. 项目介绍
本项目是一个基于 C++20 标准实现的高性能、高可配置线程池，支持固定线程数（FIXED）和动态扩缩容（CACHED）两种核心工作模式，同时提供多线程池共享任务队列、支持队列任务多线程池竞争处理、任务异常传递、队列容量限制等增强特性。核心设计目标是解决多线程编程中线程创建销毁开销大、任务调度混乱、资源利用率低等问题，为高并发场景提供高效、稳定的任务执行框架。

项目采用模块化设计，将任务队列与线程池解耦，支持单个任务队列被多个线程池共享，灵活适配不同并发需求；通过 RAII 机制确保资源安全回收，避免内存泄漏和僵尸线程；完善的异常传递机制保证任务执行异常可追溯，提升调试效率。

## 3. 核心特性

### 双模式工作支持
- **FIXED模式**：固定线程数，（默认）核心线程数=最大线程数，适用于任务量稳定的场景，避免线程频繁创建销毁开销；
- **CACHED 模式**：动态扩缩容，支持根据任务量自动调整线程数（核心线程数~最大线程数），适用于任务量波动大的场景，提升资源利用率。
  
### 多池共享任务队列
- 任务队列与线程池解耦，单个任务队列可绑定多个线程池，实现任务在多线程池间的负载均衡，且关闭线程池不会与任务队列解除绑定，重启后仍可处理队列任务，唯有销毁线程池时解除绑定。

### 完善的任务管理
- 支持任意类型任务（有/无返回值），通过 std::any 实现类型擦除，统一任务接口；
- 任务队列支持容量限制，队列满时自动拒绝新任务，避免内存溢出；
- 基于 std::promise/std::future 实现任务结果传递和异常捕获，确保异常可追溯。

### 高可靠性保障
- FIXED 模式内置守护者线程，实时监控线程状态，自动补充异常退出的线程，保证线程数稳定；
- CACHED 模式内置管理者线程，定期清理空闲线程、动态调整线程数，优化资源占用；

### 优雅关机机制
- 关闭时唤醒所有线程处理剩余任务，拒绝新任务，确保资源安全回收。

### 高可配置性
- 支持动态调整任务队列容量、CACHED 模式扩容步长，支持线程池重命名、重启等操作，适配多样化需求。

### 线程安全设计
- 采用原子变量、互斥锁、条件变量等同步机制，确保多线程环境下任务调度、状态管理的线程安全。

## 4. 快速开始

### 环境要求
- 编译器：支持 C++20 及以上标准；
- 操作系统：跨平台支持（Windows、Linux、macOS）；
- 依赖：无第三方依赖，仅依赖 C++ 标准库。

### 编译运行
1. 将项目文件分为 ThreadPool.hpp（头文件，包含核心实现）和 main（测试文件）；
2. 编译命令(GCC)
```bash
g++ main.cpp -o hreadpool_test -std=c++20 -lpthread
```
3. 运行
```
./threadpool_test    # Linux/macOS

threadpool_test.exe  # Windows
```

### 使用示例
```cpp
#include "ThreadPool.hpp"
#include <iostream>
#include <future>

int main() {
    // 1. 创建任务队列（容量限制为 10）
    TaskQueue queue(10);
    
    // 2. 创建 FIXED 模式线程池
    // 参数：线程池id, 绑定的任务队列, 模式, 核心线程数（默认为cpu线程数）
    ThreadPool pool("Test-Pool", &queue, PoolMode::FIXED, 2);
    
    // 2. 或创建 CACHED 模式线程池
    // 参数：线程池id, 绑定的任务队列, 模式, 最小线程数，最大线程数
    // ThreadPool pool("Test-Pool", &queue, PoolMode::CACHED, 2, 12);

    // 3. 提交无返回值任务
    auto f1 = pool.submitTask([]() {
        std::this_thread::sleep_for(std::chrono::milliseconds(200));
        std::cout << "无返回值任务执行完成" << std::endl;
    });
    f1.get();  // 等待任务完成
    
    // 4. 提交有返回值任务（两数相加）
    auto f2 = pool.submitTask([](int a, int b) {
        return a + b;
    }, 10, 20);

    int sum = std::any_cast<int>(f2.get());
    std::cout << "10 + 20 = " << sum << std::endl;
    
    // 5. 手动关闭线程池（析构自动调用）
    pool.shutdownPool();
    
    // 6. 重命名 (仅线程池关闭时可调用)
    pool.Rename("Test-Pool-1");

    // 7. 重启线程池可接着执行任务
    pool.resumePool();
    
    return 0;
}
```

## 5. 详细说明

### 核心模块

#### 任务(Task)
任务封装结构体：统一管理任意类型任务（支持有/无返回值、异常传递）
- 用可调用对象封装器打包
  `std::function<std::any()> func;` 将任务参数打包进func内，无参数，返回any（兼容任意返回值）
- 智能指针管理promise
  `std::shared_ptr<std::promise<std::any>> promise;` 用于传递任务结果/异常的promise

#### 任务队列(TaskQueue)
任务队列是线程池的任务载体，负责存储、管理任务，并支持多线程池绑定，实现添加任务多线程池竞争处理。核心接口：
- `submitTask(Func&& func, Args&&... args)`：提交任务，返回 `std::future<std::any>`，供用户获取结果或捕获异常；
- `shutdownQueue()`：关闭队列，拒绝新任务，唤醒所有绑定线程池的线程处理剩余任务；
- `setMaxCapacity(int capacity)`：动态调整队列最大容量；
- `taskTake()`：工作线程调用，从队列取出任务；
- `bindConditionVariable(std::condition_variable* cond)`：绑定线程池的条件变量，实现任务入队时唤醒线程；
- `unbindConditionVariable(std::condition_variable* cond)`：线程池销毁/关机时调用，避免野指针。

#### 线程池（ThreadPool）
线程池是核心调度模块，负责管理工作线程、调度任务执行。

**构造函数：**
- FIXED 模式：`ThreadPool(std::string name, TaskQueue* taskq, PoolMode::FIXED, int livenum = std::thread::hardware_concurrency());`
- CACHED 模式：`ThreadPool(std::string name, TaskQueue* taskq, PoolMode::CACHED, int min, int max);`

**核心功能接口：**
- `submitTask(Func&& func, Args&&... args)`：提交任务（对外核心接口）；
- `shutdownPool()`：关闭线程池，回收所有线程；
- `resumePool()`：重启已关闭的线程池（队列未关闭时有效）；
- `setEverytimeAddCount(int num)`：设置 CACHED 模式每次扩容的线程数；
- `setQueueMaxCapacity(int capacity)`：动态调整关联任务队列的最大容量。

**状态查询接口：**
- `getLiveNum()`：获取当前存活线程数；
- `getBusyNum()`：获取当前正在执行任务的忙线程数；
- `getQueueCurrentSize()`：获取任务队列当前任务数。

### 工作模式详解

#### FIXED 模式
- **核心特性**：线程数固定，(默认为cpu线程数)核心线程数=最大线程数，无动态扩缩容；
- **守护者线程**：内置守护者线程，实时监控工作线程状态，若线程异常退出，自动清理无效线程并补充新线程，确保线程数稳定；
- **适用场景**：任务量稳定、任务执行时间均衡的场景（如后台定时任务、数据同步任务）。

#### CACHED 模式
- **核心特性**：支持动态扩缩容，线程数在核心线程数（min）和最大线程数（max）之间波动；
- **管理者线程**：定期（3 秒）监控线程池状态，执行扩缩容和无效线程清理；
- **扩容逻辑**：当队列任务积压（任务数>存活线程数）且存活线程数<最大线程数时，自动扩容（每次扩容步长可配置）；
- **缩容逻辑**：当忙线程数的 2 倍 < 存活线程数（线程空闲过多）且存活线程数>核心线程数时，自动缩容到核心线程数；
- **适用场景**：任务量波动大、任务执行时间短的场景（如 Web 服务器请求处理、临时批量任务）。

## 6. 测试
项目内置 8 组测试用例，覆盖核心功能、边界场景和高并发场景，运行测试程序即可执行所有测试（按回车键逐步执行）：
1. **基础功能测试**：验证 FIXED 模式、有/无返回值任务执行；
2. **多线程池共享任务队列测试**：验证单个任务队列被多个线程池共享的正确性；
3. **CACHED 模式动态扩缩容测试**：验证动态扩容、缩容逻辑；
4. **队列容量限制与任务拒绝测试**：验证队列满时拒绝新任务的逻辑；
5. **异常传递测试**：验证任务执行异常的捕获与传递；
6. **线程池销毁/关机自动解绑测试**：验证线程池析构或手动关机时自动解绑任务队列；
7. **队列关闭测试**：验证队列关闭后拒绝新任务、处理剩余任务的逻辑；
8. **高并发压力测试**：100 个任务+多线程池并发执行，验证性能与稳定性。

## 7. 注意事项
- 任务队列关闭后，无法提交新任务，仅能处理已入队的剩余任务；
- 线程池重启仅支持已关闭且关联任务队列未关闭的场景；
- 任务函数中若存在未捕获的异常，会被线程池捕获并通过 `std::future` 传递给用户，建议用户在获取任务结果时通过 try-catch 捕获异常；
- 多线程池共享任务队列时，所有线程池都会响应任务入队事件，实现任务负载均衡；
- 编译时需指定 C++20 及以上标准，并链接线程库（如 GCC 需添加 `-lpthread` 参数）。

## 8. 扩展方向
本项目可基于现有架构进一步扩展，适配更复杂的并发场景：
- **添加任务优先级支持**：修改任务队列为优先级队列，实现高优先级任务优先执行；
- **支持任务超时取消**：基于定时器实现任务超时检测，取消超时未执行的任务；
- **添加线程池监控面板**：统计任务执行耗时、线程利用率等指标，输出可视化日志；
- **支持任务批量提交**：优化批量任务的入队效率，减少锁竞争；
- **适配分布式场景**：将任务队列替换为分布式消息队列（如 Redis、RabbitMQ），实现分布式线程池。

## 9. 开发过程中出现的问题

1. **开发CACHED模式的过程中**
   - **问题**：核心线程数组函数容量只增不减
   - **原因**：若在频繁的增容和缩容后，核心线程数组会越来越大
   - **解决方法**：将线程与其状态封装成WorkerStatus类，用对象成员isFinish来判断是否退出，在管理者线程中增加自动清理已经退出的线程来保证数组的size不大于设置的最大线程数。

2. **CACHED模式测试过程中**
   - **问题**：测试增容减容时busyNum断言未通过
   - **原因**：busyNum虽然为原子变量但在手动操作过程中依旧无法避免计数不正确
   - **解决方法**：参考std::lock_guard的实现方法也就是RAII机制，将busyNum和专门用于锁busyNum的锁一同封装起来，实现在构造时自动++，析构时自动--，不需要手动管理。

3. **开发增加模式切换的过程中**
   - **问题**：FIXED模式下无法析构线程池出现无限阻塞
   - **原因**：线程接收信息不同步导致少量线程无法收到关机信号
   - **解决方法**：采用双重唤醒且每次间隔100ms

4. **开发任务队列与线程池解耦的过程中**
   - **问题**：线程池无法正常析构出现无限阻塞
   - **原因**：析构过程中按照了错误的顺序调用导致先解绑任务队列后没有途径唤醒阻塞中的核心线程
   - **解决方法**：在发出关机信号后先唤醒核心线程后再解绑任务队列

5. **测试FIXED模式下能否抛出异常的过程中**
   - **问题**：程序卡住，线程池无法正常处理任务
   - **原因**：FIXED模式下没有类似于CACHED模式下的管理者函数来自动检测线程数量是否正常，在核心线程执行异常后会自动退出线程，在处理若干个任务后就会出现线程池没有核心线程去处理任务的情况
   - **解决方法**：基于Semaphore（需要C++20，也可以用互斥锁和条件变量自行实现）信号量实现对标管理者线程的守护者线程来实现自动检测并增加核心线程和处理已退出的线程。


